// swaps two numbers 
void swap(int* a , int*b) 
{ 
    int temp = *a; 
    *a = *b; 
    *b = temp; 
} 
  
// returns absolute value of number 
float absolute(float x ) 
{ 
    if (x < 0) return -x; 
    else return x; 
} 
  
//returns integer part of a floating point number 
int iPartOfNumber(float x) 
{ 
    return (int)x; 
} 
  
//rounds off a number 
int roundNumber(float x) 
{ 
    return iPartOfNumber(x + 0.5) ; 
} 
  
//returns fractional part of a number 
float fPartOfNumber(float x) 
{ 
    if (x>0) return x - iPartOfNumber(x); 
    else return x - (iPartOfNumber(x)+1); 
  
} 
  
//returns 1 - fractional part of number 
float rfPartOfNumber(float x) 
{ 
    return 1 - fPartOfNumber(x); 
} 
  
// draws a pixel on screen of given brightness 
// 0<=brightness<=1. We can use your own library 
// to draw on screen 
void drawPixel( int x , int y , float brightness) 
{ 
    int c = 255*brightness; 
    SDL_SetRenderDrawColor(pRenderer, c, c, c, 255); 
    SDL_RenderDrawPoint(pRenderer, x, y); 
} 
  
void drawAALine(int x0 , int y0 , int x1 , int y1) 
{ 
    int steep = absolute(y1 - y0) > absolute(x1 - x0) ; 
  
    // swap the co-ordinates if slope > 1 or we 
    // draw backwards 
    if (steep) 
    { 
        swap(&x0 , &y0); 
        swap(&x1 , &y1); 
    } 
    if (x0 > x1) 
    { 
        swap(&x0 ,&x1); 
        swap(&y0 ,&y1); 
    } 
  
    //compute the slope 
    float dx = x1-x0; 
    float dy = y1-y0; 
    float gradient = dy/dx; 
    if (dx == 0.0) 
        gradient = 1; 
  
    int xpxl1 = x0; 
    int xpxl2 = x1; 
    float intersectY = y0; 
  
    // main loop 
    if (steep) 
    { 
        int x; 
        for (x = xpxl1 ; x <=xpxl2 ; x++) 
        { 
            // pixel coverage is determined by fractional 
            // part of y co-ordinate 
            drawPixel(iPartOfNumber(intersectY), x, 
                        rfPartOfNumber(intersectY)); 
            drawPixel(iPartOfNumber(intersectY)-1, x, 
                        fPartOfNumber(intersectY)); 
            intersectY += gradient; 
        } 
    } 
    else
    { 
        int x; 
        for (x = xpxl1 ; x <=xpxl2 ; x++) 
        { 
            // pixel coverage is determined by fractional 
            // part of y co-ordinate 
            drawPixel(x, iPartOfNumber(intersectY), 
                        rfPartOfNumber(intersectY)); 
            drawPixel(x, iPartOfNumber(intersectY)-1, 
                          fPartOfNumber(intersectY)); 
            intersectY += gradient; 
        } 
    } 


  //////

  double	frc_part(double nbr)
  {
  	return (ceil(nbr) - nbr);
  }

  void	draw_w_slope(t_frame *frm, double x, double y)
  {
  	if (frm->slope >= 0)
  	{
  		fill_img(frm, floor(x), y, 1 - frc_part(y));
  		fill_img(frm, floor(x) + 1, y, frc_part(y));
  	}
  	else if (frm->slope < 0)
  	{
  		fill_img(frm, floor(x), y, 1 - frc_part(y));
  		fill_img(frm, floor(x) - 1, y, frc_part(y));
  	}
  }

  void	draw_btw_dots(t_frame *frm, t_vct p1, t_vct p2)
  {
  	while (p1.x <= p2.x)
  	{
  		if (frm->steep)
  			draw_w_slope(frm, p1.y, p1.x);
  		else
  			draw_w_slope(frm, p1.x, p1.y);
  		p1.y += frm->slope;
  		p1.x++;
  	}
  }

  void	draw_line(t_frame *frm, t_vct p1, t_vct p2)
  {
  	double	dx;
  	double	dy;

  	frm->steep = fabs(p1.y - p2.y) > fabs(p1.x - p2.x) ? 1 : 0;
  	if (frm->steep)
  	{
  		swap(&p1.x, &p1.y);
  		swap(&p2.x, &p2.y);
  	}
  	if (p2.x < p1.x)
  	{
  		swap(&p1.x, &p2.x);
  		swap(&p1.y, &p2.y);
  	}
  	dx = p2.x - p1.x;
  	dy = p2.y - p1.y;
  	frm->slope = dx == 0 ? 1 : dy / dx;
  	draw_btw_dots(frm, p1, p2);
  }
////
  We begin with a derivation of the Gupta/Sproull algorithm for drawing antialiased lines, this is covered in Ch 3.17. If we let D_x be the distance between the line and the closest pixel at the x+1 position, (either E or NE), then
    D_x = (d + dx)/(2*sqrt(dx^2+dy^2))    if the closest pixel is E
    D_x = (d - dx)/(2*sqrt(dx^2+dy^2))    if the closest pixel is NE
  Based on this computation we can easily modify the Bresenham Midpoint algorithm to compute antialiased pixel intensities.
   void draw(int x0, int y0, int x1,int y1) {
    int dx = x1-x0;
    int dy = y1-y0;
    int d=2*dy-dx;
    int incrE = 2*dy;
    int incrNE = 2*(dy-dx);
    // code added for antialiasing
        int two_v_dx = 0;
        double invDenom = 1.0/(2.0*Math.sqrt(dx*dx+dy*dy));
        double two_dx_invDemon = 2.0*dx*invDenom;
    //
    int x = x0;
    int y = y0;
    // code added for antialiasing
        IntensifyPixel(x,y,0);                       // start pixel
        IntensifyPixel(x,y+1,two_dx_invDenom);       // neighbor above
        IntensifyPixel(x,y-1,two_dx_invDenom);       // neighbor below
    //
    while (x<x1) {
      if (d<0) {
        // code added for antialiasing
            two_v_dx = d+dx;
        //
        d += incrE;
        x++;
      }else {
        // code added for antialiasing
            two_v_dx = d-dx;
        //
        d += incrNE;
        x++;
        y++;
      }
     // code added for antialiasing
          IntensifyPixel(x,y,two_v_dx*invDenom);
          IntensifyPixel(x,y+1,two_dx_invDenom - two_v_dx*invDenom);
          IntensifyPixel(x,y-1,two_dx_invDenom + two_v_dx*invDenom);
     //
    }
   }

   void IntensifyPixel(int x, int y, double distance) {
    double intensity = Filter(Math.round(Math.abs(distance)));
    WritePixel(x,y,intensity);
   }
